import streamlit as st
import pandas as pd
import pdfplumber
from io import BytesIO

st.title("Agrupador de Processos ðŸ“‚")
st.set_page_config(page_title="Gerenciador de Tarefas", page_icon="âœ…", layout="wide")

uploaded_file = st.file_uploader("FaÃ§a o upload da planilha (.xlsx)", type=["xlsx"])
st.title("Gerenciador de Tarefas em PDF")

if uploaded_file is not None:
    df = pd.read_excel(uploaded_file)
    st.write("### PrÃ©via dos dados:")
    st.dataframe(df.head())
# Inicializa o armazenamento de tarefas persistente em sessao
if "tarefas" not in st.session_state:
    st.session_state["tarefas"] = pd.DataFrame()

    required_columns = ["NÃºmero do processo", "Ã“rgÃ£o"]
    if all(col in df.columns for col in required_columns):
        df_grouped = df.groupby("NÃºmero do processo").apply(lambda x: x).reset_index(drop=True)
        st.write("### Dados Agrupados por NÃºmero do Processo:")
        st.dataframe(df_grouped)
uploaded_pdf = st.file_uploader(
    "Anexe um PDF com as tarefas", type=["pdf"], accept_multiple_files=False
)

        df_count = df.groupby(["NÃºmero do processo", "Ã“rgÃ£o"]).size().reset_index(name="Quantidade de RepetiÃ§Ãµes")
        st.write("### Contagem de RepetiÃ§Ãµes por Processo e Ã“rgÃ£o:")
        st.dataframe(df_count)
@st.cache_data(show_spinner=False)
def pdf_to_df(file_bytes: bytes) -> pd.DataFrame:
    """Extrai tabelas de um PDF retornando um DataFrame."""
    with pdfplumber.open(BytesIO(file_bytes)) as pdf:
        tables = []
        for page in pdf.pages:
            for table in page.extract_tables():
                if table:
                    tables.append(pd.DataFrame(table[1:], columns=table[0]))
        return pd.concat(tables, ignore_index=True) if tables else pd.DataFrame()

        csv = df_count.to_csv(index=False).encode("utf-8")
        st.download_button(
            label="Baixar dados agrupados com contagem",
            data=csv,
            file_name="dados_agrupados_contagem.csv",
            mime="text/csv",
        )
if uploaded_pdf is not None:
    pdf_bytes = uploaded_pdf.read()
    novas_tarefas = pdf_to_df(pdf_bytes)
    if novas_tarefas.empty:
        st.warning("Nenhuma tabela foi encontrada no PDF.")
    else:
        st.error("A planilha deve conter as colunas 'NÃºmero do processo' e 'Ã“rgÃ£o'.")
        st.session_state["tarefas"] = pd.concat(
            [st.session_state["tarefas"], novas_tarefas], ignore_index=True
        )
        st.success("Tarefas adicionadas!")

# Dados atuais
df = st.session_state["tarefas"]

if df.empty:
    st.info("Nenhuma tarefa carregada. Envie um PDF para comeÃ§ar.")
    st.stop()

# Converte a coluna Prazo para datetime quando existir
if "Prazo" in df.columns:
    df["Prazo"] = pd.to_datetime(df["Prazo"], errors="coerce")

with st.sidebar:
    st.header("Filtros")
    responsaveis = df["ResponsÃ¡vel"].dropna().unique().tolist() if "ResponsÃ¡vel" in df.columns else []
    selected_resp = st.multiselect("ResponsÃ¡vel", options=responsaveis, default=responsaveis)
    data_ini = st.date_input("Prazo a partir de", value=None)
    data_fim = st.date_input("Prazo atÃ©", value=None)
    if st.button("Limpar tarefas"):
        st.session_state["tarefas"] = pd.DataFrame()
        st.experimental_rerun()

filtro = df.copy()
if selected_resp:
    filtro = filtro[filtro["ResponsÃ¡vel"].isin(selected_resp)]
if "Prazo" in filtro.columns:
    if data_ini:
        filtro = filtro[filtro["Prazo"] >= pd.to_datetime(data_ini)]
    if data_fim:
        filtro = filtro[filtro["Prazo"] <= pd.to_datetime(data_fim)]

st.subheader("Tarefas Filtradas")
st.dataframe(filtro, use_container_width=True)

csv = filtro.to_csv(index=False).encode("utf-8")
st.download_button(
    label="Baixar CSV",
    data=csv,
    file_name="tarefas_filtradas.csv",
    mime="text/csv",
)
